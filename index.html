<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>è³¢è€…é—–é¬¼å±‹ï¼šHaunted Lexicon</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
    }

    body {
      background: #000;
      color: #f5f5f5;
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100vw;
      /* ä½¿ç”¨ dvh é¿å…æ‰‹æ©Ÿç€è¦½å™¨å·¥å…·åˆ—é®æ“‹ï¼Œfallback ç‚º 100vh */
      height: 100vh;
      height: 100dvh;
      overflow: hidden; /* ç¦æ­¢æ²å‹• */
      padding: 0;
      margin: 0;
    }

    .game-shell {
      width: 100%;
      height: 100%;
      position: relative;
      background: radial-gradient(circle at center, #1a1e29, #000 80%);
      display: flex;
      justify-content: center;
      align-items: center;
    }

    /* éŠæˆ²ç•«å¸ƒï¼šä¿æŒæ¯”ä¾‹ï¼Œæœ€å¤§åŒ–é¡¯ç¤º */
    canvas {
      display: block;
      max-width: 100%;
      max-height: 100%;
      width: auto;
      height: auto;
      aspect-ratio: 900 / 560;
      box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
      cursor: crosshair;
      /* ç¢ºä¿ç•«å¸ƒåœ¨æ­£ä¸­é–“ */
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 1;
    }

    /* === HUD (æŠ¬é ­é¡¯ç¤ºå™¨) - éŠæˆ²ä¸­é¡¯ç¤º === */
    #hud-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 10;
      pointer-events: none; /* è®“é»æ“Šç©¿é€åˆ° Canvas */
      display: flex;
      flex-direction: column;
      justify-content: space-between;
    }

    .hud-top-bar {
      background: linear-gradient(to bottom, rgba(0,0,0,0.9), rgba(0,0,0,0));
      padding: 10px 20px 40px 20px;
      text-align: center;
      pointer-events: auto;
    }

    #current-question-text {
      font-size: 24px;
      font-weight: bold;
      color: #ffd700;
      text-shadow: 0 2px 4px rgba(0,0,0,0.8);
      margin: 4px 0;
    }

    #instruction-sub {
      font-size: 14px;
      color: #a0aaff;
      opacity: 0.9;
    }

    .status-badges {
      display: inline-flex;
      gap: 10px;
      margin-top: 4px;
      font-size: 12px;
      color: #ccc;
      background: rgba(0,0,0,0.3);
      padding: 4px 8px;
      border-radius: 12px;
    }

    /* === é¸å–®è¦†è“‹å±¤ (Menu Overlay) - é–‹å§‹/æš«åœ/çµæŸæ™‚é¡¯ç¤º === */
    #menu-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 20;
      background: rgba(10, 12, 20, 0.85);
      backdrop-filter: blur(5px);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      transition: opacity 0.3s ease;
    }

    /* ç•¶éŠæˆ²é€²è¡Œæ™‚éš±è—é¸å–® */
    #menu-overlay.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .menu-card {
      background: rgba(30, 35, 50, 0.95);
      padding: 24px;
      border-radius: 20px;
      border: 1px solid rgba(255,255,255,0.1);
      box-shadow: 0 20px 50px rgba(0,0,0,0.7);
      max-width: 90%;
      width: 400px;
    }

    .menu-title h1 {
      font-size: 28px;
      margin: 0;
      color: #fff;
      letter-spacing: 2px;
    }
    .menu-title .subtitle {
      color: #b6c1ff;
      font-size: 14px;
      margin-bottom: 16px;
    }

    #message {
      font-size: 15px;
      color: #e0e6ff;
      margin-bottom: 20px;
      line-height: 1.5;
      min-height: 24px;
    }

    #startBtn {
      width: 100%;
      padding: 16px;
      font-size: 18px;
      font-weight: bold;
      border-radius: 50px;
      border: none;
      background: linear-gradient(135deg, #5c7cff, #9f6bff);
      color: #fff;
      cursor: pointer;
      box-shadow: 0 8px 20px rgba(92, 124, 255, 0.4);
      transition: transform 0.1s ease;
    }
    #startBtn:active { transform: scale(0.96); }

    .legend {
      display: flex;
      justify-content: center;
      gap: 12px;
      margin-top: 16px;
      font-size: 12px;
      color: #aaa;
    }
    .legend-item { display: flex; align-items: center; gap: 4px; }
    .dot { width: 8px; height: 8px; border-radius: 50%; }

    /* === æ‰‹æ©Ÿå°ˆç”¨å°„æ“ŠæŒ‰éˆ• (Floating Action Button) === */
    #mobile-controls {
      position: absolute;
      /* ç¢ºä¿è·é›¢é‚Šç·£è¶³å¤ é ï¼Œé¿å…è¢«åˆ‡åˆ° */
      bottom: 60px; 
      right: 40px;
      z-index: 30; /* æœ€é«˜å±¤ç´š */
    }

    #mobileFireBtn {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: rgba(255, 215, 0, 0.4); /* ç¨å¾®å¢åŠ ä¸é€æ˜åº¦ */
      border: 4px solid #ffd700;
      color: #ffd700;
      font-size: 32px;
      display: flex;
      justify-content: center;
      align-items: center;
      box-shadow: 0 0 25px rgba(255, 215, 0, 0.6);
      backdrop-filter: blur(2px);
      transition: all 0.1s;
      user-select: none;
      touch-action: none; 
    }

    #mobileFireBtn:active {
      background: rgba(255, 215, 0, 0.8);
      color: #fff;
      transform: scale(0.92);
    }

    /* æ‰‹æ©Ÿç›´å¼å„ªåŒ– */
    @media (max-width: 600px) {
      #current-question-text { font-size: 20px; }
      .hud-top-bar { padding: 10px 10px 30px 10px; }
      /* æ‰‹æ©Ÿç‰ˆæŒ‰éˆ•ä½ç½®å„ªåŒ– */
      #mobile-controls { bottom: 50px; right: 30px; }
      #mobileFireBtn { width: 75px; height: 75px; font-size: 28px; }
      canvas { width: 100%; height: auto; }
    }
  </style>
</head>
<body>
  <div class="game-shell">
    
    <!-- éŠæˆ²ç•«å¸ƒ -->
    <canvas id="gameCanvas" width="900" height="560"></canvas>

    <!-- HUD å±¤ (éŠæˆ²ä¸­å¸¸é§é¡¯ç¤º) -->
    <div id="hud-layer">
      <div class="hud-top-bar">
        <div id="instruction-sub">ä»»å‹™ç›®æ¨™ï¼šæ¥ä½æ­£ç¢ºç­”æ¡ˆ</div>
        <div id="current-question-text">æº–å‚™é–‹å§‹</div>
        <div class="status-badges">
          <span id="levelLabel">Level 1</span>
          <span>|</span>
          <span id="progressLabel">0/10</span>
        </div>
      </div>
      <!-- åº•éƒ¨ä¿ç•™ç©ºé–“çµ¦å°„æ“ŠæŒ‰éˆ• -->
    </div>

    <!-- é¸å–®å±¤ (é–‹å§‹/æš«åœ/çµæŸ) -->
    <div id="menu-overlay">
      <div class="menu-card">
        <div class="menu-title">
          <h1>è³¢è€…é—–é¬¼å±‹</h1>
          <div class="subtitle">Haunted Lexicon</div>
        </div>
        
        <div id="message">æŒ‰ä¸‹é–‹å§‹ï¼Œæ¥ä½æ­£ç¢ºå–®å­—ï¼Œç™¼å°„é­”æ³•å…‰æ³¢ï¼</div>
        
        <button id="startBtn">é–‹å§‹æŒ‘æˆ°</button>
        
        <div class="legend">
           <div class="legend-item"><div class="dot" style="background:#fff; border:1px solid #aaa"></div>æ¥æ­£ç¢ºå­—</div>
           <div class="legend-item"><div class="dot" style="background:#ff4d4d"></div>å°„æ“Šç«çƒ</div>
           <div class="legend-item"><div class="dot" style="background:#c0d4ff"></div>å°„æ“Šå¹½éˆ</div>
        </div>
        <div style="font-size:12px; color:#666; margin-top:10px;">(é›»è…¦æŒ‰ç©ºç™½éµ / æ‰‹æ©ŸæŒ‰å³ä¸‹è§’)</div>
      </div>
    </div>

    <!-- æ‡¸æµ®æ“ä½œæŒ‰éˆ• -->
    <div id="mobile-controls">
      <div id="mobileFireBtn">ğŸ¹</div>
    </div>

  </div>

  <script>
    // ====== åŸºæœ¬è¨­å®š ======
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    const messageEl = document.getElementById("message");
    const questionTextEl = document.getElementById("current-question-text");
    const instructionSubEl = document.getElementById("instruction-sub");
    const startBtn = document.getElementById("startBtn");
    const levelLabel = document.getElementById("levelLabel");
    const progressLabel = document.getElementById("progressLabel");
    const mobileFireBtn = document.getElementById("mobileFireBtn");
    const menuOverlay = document.getElementById("menu-overlay");

    let WIDTH = 900;
    let HEIGHT = 560;

    // ====== åœ–ç‰‡è³‡æºè¨­å®š (å¯æ›¿æ›) ======
    const imagePaths = {
      player: "shooter.png", 
      ghost: "ghost.png",  
      boss: "king.png"     
    };

    const defaultSvg = {
      player: "data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Cpath fill='%235c7cff' d='M32 2L10 20v40h44V20L32 2z'/%3E%3Ccircle cx='32' cy='28' r='10' fill='%23f8e0c8'/%3E%3Cpath fill='%238a2be2' d='M32 2L16 20h32L32 2z'/%3E%3Cpath stroke='%23ffd700' stroke-width='3' d='M44 36l12-8M44 36l12 8'/%3E%3C/svg%3E",
      ghost: "data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Cpath fill='%23c0d4ff' d='M32 2C15.4 2 2 15.4 2 32v20l10-6 10 6 10-6 10 6 10-6 10 6V32c0-16.6-13.4-30-30-30z' opacity='0.9'/%3E%3Ccircle cx='22' cy='24' r='4' fill='%2327304a'/%3E%3Ccircle cx='42' cy='24' r='4' fill='%2327304a'/%3E%3C/svg%3E",
      boss: "data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ccircle cx='50' cy='50' r='45' fill='%23ff3333'/%3E%3Cpath fill='%23ffd700' d='M20 30l10-20 20 15 20-15 10 20z'/%3E%3Ccircle cx='35' cy='55' r='6' fill='%2300ffff'/%3E%3Ccircle cx='65' cy='55' r='6' fill='%2300ffff'/%3E%3Cpath stroke='%23330000' stroke-width='4' fill='none' d='M30 75q20 15 40 0'/%3E%3C/svg%3E"
    };

    const assets = {
      player: new Image(),
      ghost: new Image(), 
      boss: new Image()    
    };

    function loadGameImages() {
      assets.player.onerror = () => { assets.player.src = defaultSvg.player; };
      assets.player.src = imagePaths.player;

      assets.ghost.onerror = () => { assets.ghost.src = defaultSvg.ghost; };
      assets.ghost.src = imagePaths.ghost;

      assets.boss.onerror = () => { assets.boss.src = defaultSvg.boss; };
      assets.boss.src = imagePaths.boss;
    }

    loadGameImages();

    // ====== é¡Œåº« ======
    // å·²æ ¹æ“šä½¿ç”¨è€…è¦æ±‚æ›´æ–°å–®å­—åº«
    const vocabQuestions = [
      { zh: "æ··äº‚çš„", en: "messy", options: ["messy", "missy", "massy", "mossy"] },
      { zh: "ä¸Ÿæ£„", en: "throw away", options: ["throw away", "run away", "fly away", "go away"] },
      { zh: "çŸ­è¢–è¥¯è¡«", en: "a short-sleeved shirt", options: ["a short-sleeved shirt", "a long-sleeved shirt", "a sleeveless shirt", "a checkered shirt"] },
      { zh: "åŠæ›", en: "hang", options: ["hang", "hand", "hung", "bang"] },
      { zh: "çŸ­è¤²", en: "shorts", options: ["shorts", "shirts", "sports", "shots"] },
      { zh: "å¥³ç”¨è¥¯è¡«", en: "blouse", options: ["blouse", "house", "mouse", "browse"] },
      { zh: "å¤§è¡£", en: "a coat", options: ["a coat", "a boat", "a goat", "a float"] },
      { zh: "æ¯›è¡£", en: "a sweater", options: ["a sweater", "a sweeter", "a weather", "a waiter"] },
      { zh: "é«˜é ˜", en: "a turtleneck", options: ["a turtleneck", "a turtleback", "a turnbuckle", "a bottleneck"] },
      { zh: "æ€¥æ•‘ç®±", en: "a first-aid kit", options: ["a first-aid kit", "a fast-food kit", "a first-class kit", "a band-aid kit"] },
      { zh: "å……é›»å™¨", en: "a charger", options: ["a charger", "a changer", "a larger", "a danger"] },
      { zh: "å¹³æ¿", en: "a tablet", options: ["a tablet", "a table", "a talent", "a target"] },
      { zh: "ç¹ƒå¸¶", en: "bandages", options: ["bandages", "bondages", "bridges", "badges"] },
      { zh: "é«®ç®", en: "hair bands", options: ["hair bands", "hand bags", "head bands", "air bands"] },
      { zh: "è‹±éŠ", en: "pound", options: ["pound", "sound", "round", "found"] },
    ];

    const conjQuestions = [
      { sentence: "I stayed home ____ it was raining heavily.", answer: "because", options: ["because", "but", "so", "or"] },
      { sentence: "You can have tea ____ coffee.", answer: "or", options: ["or", "and", "so", "because"] },
      { sentence: "He was tired, ____ he went to bed early.", answer: "so", options: ["so", "because", "but", "although"] },
      { sentence: "She bought some bread ____ milk.", answer: "and", options: ["and", "or", "but", "so"] },
      { sentence: "____ he was sick, he still went to work.", answer: "Although", options: ["Although", "Because", "If", "So"] },
      { sentence: "I wanted to go jogging, ____ it started to rain.", answer: "but", options: ["but", "and", "so", "or"] },
      { sentence: "She studied hard ____ she could pass the exam.", answer: "so", options: ["so", "because", "but", "although"] },
      { sentence: "We didnâ€™t go out ____ we had no money.", answer: "because", options: ["because", "although", "so", "but"] },
      { sentence: "You should hurry, ____ you will miss the bus.", answer: "or", options: ["or", "and", "so", "because"] },
      { sentence: "He is smart ____ very hardworking.", answer: "and", options: ["and", "but", "or", "so"] },
    ];

    // ====== éŠæˆ²ç‹€æ…‹ ======
    const game = {
      state: "menu", // menu, level1, level2, gameOver, victory
      level: 0,
      hp: 5,
      maxHp: 5,
      ghosts: [],
      wordProjectiles: [], 
      attackProjectiles: [], 
      playerArrows: [], 
      goldenWaves: [], 
      effects: [], 
      player: null,
      boss: null,
      currentQuestions: [],
      currentIndex: 0,
      lastTime: 0,
      hitEffectTime: 0,
      flashTime: 0,
      touchTarget: null,
      wordSpawnTimer: 0,
      attackSpawnTimer: 0,
    };

    // ====== å·¥å…·å‡½æ•¸ ======
    function randRange(min, max) {
      return Math.random() * (max - min) + min;
    }

    function shuffleArray(arr) {
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    // ====== ç‰©ä»¶å‰µå»º ======
    function createPlayer() {
      return {
        x: WIDTH * 0.1,
        y: HEIGHT * 0.5,
        w: 80, // [ä¿®æ”¹] æ”¾å¤§ç©å®¶å°ºå¯¸
        h: 80, // [ä¿®æ”¹] æ”¾å¤§ç©å®¶å°ºå¯¸
        speed: 280,
        vx: 0,
        vy: 0,
        attackCooldown: 0
      };
    }

    function createGhost(isBossMinion = false) {
      const x = randRange(WIDTH * 0.5, WIDTH - 50);
      const y = randRange(60, HEIGHT - 60);
      return {
        x,
        y,
        r: 35, // [ä¿®æ”¹] æ”¾å¤§å¹½éˆåŠå¾‘
        vx: randRange(-30, 30),
        vy: randRange(-30, 30),
        alpha: randRange(0.8, 1.0),
        wobble: Math.random() * Math.PI * 2,
        isBossMinion: isBossMinion,
        attackCooldown: randRange(1, 3),
        hitFlash: 0
      };
    }

    function createBoss() {
      const bossHp = conjQuestions.length;
      return {
        x: WIDTH * 0.85,
        y: HEIGHT * 0.5,
        r: 140, // Boss ç¶­æŒå·¨å¤§
        vx: 0,
        vy: 120,
        maxHp: bossHp,
        hp: bossHp,
        attackCooldown: 1.5,
        hitFlash: 0
      };
    }

    function createPlayerArrow(x, y) {
      return {
        x: x,
        y: y,
        vx: 600, 
        vy: 0,
        w: 24,
        h: 6,
        life: 2.0
      };
    }

    function createGoldenWave(x, y, targetX, targetY) {
      const angle = Math.atan2(targetY - y, targetX - x);
      return {
        x: x,
        y: y,
        speed: 600, 
        vx: Math.cos(angle) * 600, 
        vy: Math.sin(angle) * 600,
        r: 30, 
        angle: angle,
        life: 5.0, 
        homing: true 
      };
    }

    function createEffect(x, y, color, size = 25) {
      return {
        x, y, color,
        r: 2,
        maxR: size,
        alpha: 1.0,
        life: 0.4
      };
    }

    function createWordProjectile(sourceX, sourceY, targetX, targetY, text, isCorrect) {
        const angle = Math.atan2(targetY - sourceY, targetX - sourceX);
        const speed = isCorrect ? 160 : 200; 
        
        // [ä¿®æ”¹] èª¿æ•´å–®å­—æ³¡æ³¡çš„å‹•æ…‹åŠå¾‘è¨ˆç®—ï¼Œè®“æ³¡æ³¡æ›´å¤§æ›´é©åˆé–±è®€
        const baseRadius = 32; // åŠ å¤§åŸºç¤åŠå¾‘
        const charWidthApprox = 14; // åŠ å¤§å­—å¯¬ä¼°ç®—
        const textWidth = text.length * charWidthApprox;
        const radius = Math.max(baseRadius, (textWidth / 2) + 16);

        return {
            x: sourceX,
            y: sourceY,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            text: text,
            isCorrect: isCorrect,
            r: radius,
            life: 6.0, 
            type: 'word'
        };
    }

    function createAttackProjectile(sourceX, sourceY, targetX, targetY, type) {
        const angle = Math.atan2(targetY - sourceY, targetX - sourceX);
        let speed, r, color;
        
        if (type === 'fire') {
            speed = 350;
            r = 12;
            color = '#ff4d4d'; 
        } else if (type === 'beam') {
            speed = 450;
            r = 18;
            color = '#4da6ff'; 
        }

        return {
            x: sourceX,
            y: sourceY,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            r: r,
            life: 3.0,
            type: type,
            color: color,
            rotation: angle
        };
    }

    // ====== è¼¸å…¥æ§åˆ¶ ======
    const keys = {};
    window.addEventListener("keydown", (e) => {
      if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight", " "].indexOf(e.key) > -1) {
        if (game.state === "level1" || game.state === "level2") e.preventDefault();
      }
      keys[e.key] = true;
      
      if (e.key === " " && (game.state === "level1" || game.state === "level2")) {
        tryShoot();
      }
      game.touchTarget = null;
    });
    window.addEventListener("keyup", (e) => keys[e.key] = false);

    function tryShoot() {
        if (!game.player) return;
        if (game.player.attackCooldown <= 0) {
            game.playerArrows.push(createPlayerArrow(game.player.x + 20, game.player.y));
            game.player.attackCooldown = 0.35; 
            game.player.x = Math.max(30, game.player.x - 5);
        }
    }

    // æ‰‹æ©Ÿå°„æ“ŠæŒ‰éˆ•æ§åˆ¶
    mobileFireBtn.addEventListener("touchstart", (e) => {
      e.preventDefault(); 
      tryShoot();
      mobileFireBtn.style.transform = "scale(0.9)";
      mobileFireBtn.style.background = "rgba(255, 215, 0, 0.8)";
    }, {passive: false});

    mobileFireBtn.addEventListener("touchend", (e) => {
      e.preventDefault();
      mobileFireBtn.style.transform = "scale(1)";
      mobileFireBtn.style.background = "rgba(255, 215, 0, 0.5)";
    }, {passive: false});


    function handleTouch(e) {
      if (game.state !== "level1" && game.state !== "level2") return;
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      // è¨ˆç®—ç¸®æ”¾æ¯”ä¾‹
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const touch = e.touches[0];
      game.touchTarget = {
        x: (touch.clientX - rect.left) * scaleX,
        y: (touch.clientY - rect.top) * scaleY
      };
    }
    canvas.addEventListener("touchstart", handleTouch, {passive: false});
    canvas.addEventListener("touchmove", handleTouch, {passive: false});
    canvas.addEventListener("touchend", (e) => {
      e.preventDefault();
      game.touchTarget = null;
    });

    // ====== éŠæˆ²æµç¨‹æ§åˆ¶ ======
    startBtn.addEventListener("click", () => {
      startLevel1();
    });

    function toggleMenu(show) {
      if(show) {
        menuOverlay.classList.remove('hidden');
      } else {
        menuOverlay.classList.add('hidden');
      }
    }

    function startLevel1() {
      toggleMenu(false);
      game.state = "level1";
      game.level = 1;
      game.hp = 5;
      game.maxHp = 5;
      game.player = createPlayer();
      game.ghosts = [];
      game.wordProjectiles = [];
      game.attackProjectiles = [];
      game.playerArrows = [];
      game.goldenWaves = [];
      game.effects = [];
      for (let i = 0; i < 5; i++) game.ghosts.push(createGhost());
      game.boss = null;
      game.currentQuestions = shuffleArray(vocabQuestions);
      game.currentIndex = 0;
      game.wordSpawnTimer = 0;
      
      updateQuestionDisplay();
      updateUI("Level 1ï¼šæŒ‰ç©ºç™½éµ(Space)å°„æ“Šï¼", "Level 1", `1 / ${game.currentQuestions.length}`);
    }

    function startLevel2() {
      game.state = "level2";
      game.level = 2;
      game.hp = game.maxHp; 
      game.player = createPlayer();
      game.ghosts = [];
      game.wordProjectiles = [];
      game.attackProjectiles = [];
      game.playerArrows = [];
      game.goldenWaves = [];
      game.effects = [];
      for (let i = 0; i < 2; i++) game.ghosts.push(createGhost(true));
      game.boss = createBoss();
      game.currentQuestions = shuffleArray(conjQuestions);
      game.currentIndex = 0;
      game.wordSpawnTimer = 0;

      updateQuestionDisplay();
      updateUI("Level 2 BOSSï¼šæ¥ä½æ­£ç¢ºå–®å­—ç™¼å°„å…‰æ³¢ï¼", "Level 2 BOSS", `1 / ${game.currentQuestions.length}`);
    }

    function updateQuestionDisplay() {
        if(game.currentIndex >= game.currentQuestions.length) return;
        
        const q = game.currentQuestions[game.currentIndex];
        if(game.level === 1) {
            instructionSubEl.textContent = "ä»»å‹™ï¼šæ¥ä½ç¿»è­¯";
            questionTextEl.textContent = q.zh;
        } else {
            instructionSubEl.textContent = "ä»»å‹™ï¼šå¡«ç©º";
            let displaySentence = q.sentence.replace("____", "___");
            questionTextEl.textContent = displaySentence;
        }
        questionTextEl.style.animation = "none";
        questionTextEl.offsetHeight; 
        questionTextEl.style.animation = "pulseText 0.5s";
    }

    function updateUI(msg, lvl, prog) {
        // æ›´æ–° Overlay çš„æ–‡å­— (å¦‚æœæœ‰éœ€è¦é¡¯ç¤ºçš„è©±)
        messageEl.textContent = msg;
        // æ›´æ–° HUD
        levelLabel.textContent = lvl;
        progressLabel.textContent = prog;
    }

    function gameOver() {
        game.state = "gameOver";
        toggleMenu(true);
        messageEl.textContent = "ğŸ’€ æŒ‘æˆ°å¤±æ•—ï¼ä½ çš„ç²¾ç¥åŠ›è€—ç›¡äº†...";
        startBtn.textContent = "å†è©¦ä¸€æ¬¡";
    }

    function victory() {
        game.state = "victory";
        toggleMenu(true);
        messageEl.textContent = "ğŸ† æ­å–œï¼é­”ç‹å·²æ•—äº¡ï¼Œè³¢è€…ç²å¾—äº†æœ€çµ‚å‹åˆ©ï¼";
        startBtn.textContent = "å†æ¬¡æŒ‘æˆ°";
    }

    // ====== éŠæˆ²é‚è¼¯ (èˆ‡ä¹‹å‰ç›¸åŒï¼Œåƒ…æ›´æ–° UI å‘¼å«) ======
    function spawnWord() {
        if(game.currentIndex >= game.currentQuestions.length) return; 

        const q = game.currentQuestions[game.currentIndex];
        const isCorrectTarget = Math.random() < 0.5;
        let text = "";
        
        if (isCorrectTarget) {
            text = game.level === 1 ? q.en : q.answer;
        } else {
            const correct = game.level === 1 ? q.en : q.answer;
            const wrongs = q.options.filter(o => o !== correct);
            text = wrongs[Math.floor(Math.random() * wrongs.length)];
        }

        let sourceX, sourceY;
        if (game.level === 2 && game.boss) {
            sourceX = game.boss.x - 40;
            sourceY = game.boss.y;
        } else {
            if (game.ghosts.length > 0) {
                const g = game.ghosts[Math.floor(Math.random() * game.ghosts.length)];
                sourceX = g.x;
                sourceY = g.y;
            } else {
                sourceX = WIDTH;
                sourceY = randRange(50, HEIGHT-50);
            }
        }

        const targetX = game.player.x;
        const targetY = game.player.y + randRange(-50, 50);

        game.wordProjectiles.push(createWordProjectile(sourceX, sourceY, targetX, targetY, text, isCorrectTarget));
    }

    function respawnGhost() {
        setTimeout(() => {
            if (game.state === "level1" && game.ghosts.length < 5) {
                game.ghosts.push(createGhost());
            } else if (game.state === "level2" && game.ghosts.length < 3) {
                 game.ghosts.push(createGhost(true));
            }
        }, 1500);
    }

    function updateEnemies(dt) {
        const p = game.player;

        game.ghosts.forEach(g => {
            g.x += g.vx * dt;
            g.y += g.vy * dt;
            if(g.x > p.x + 200) g.x -= 10 * dt;
            
            if(g.x < WIDTH * 0.4 || g.x > WIDTH - 30) g.vx *= -1;
            if(g.y < 30 || g.y > HEIGHT - 30) g.vy *= -1;

            g.attackCooldown -= dt;
            if (g.attackCooldown <= 0) {
                game.attackProjectiles.push(createAttackProjectile(g.x, g.y, p.x, p.y, 'fire'));
                g.attackCooldown = randRange(2.5, 4.5);
            }
            if (g.hitFlash > 0) g.hitFlash -= dt;
        });

        if (game.boss) {
            const b = game.boss;
            b.y += b.vy * dt;
            if (b.y < 80 || b.y > HEIGHT - 80) b.vy *= -1;

            b.attackCooldown -= dt;
            if (b.attackCooldown <= 0) {
                game.attackProjectiles.push(createAttackProjectile(b.x - 40, b.y, p.x, p.y, 'beam'));
                if(Math.random() < 0.35) {
                     setTimeout(() => {
                         if(game.state === 'level2' && game.boss && game.boss.hp > 0) 
                             game.attackProjectiles.push(createAttackProjectile(b.x - 40, b.y, p.x, p.y, 'beam'));
                     }, 200);
                }
                b.attackCooldown = randRange(1.2, 2.0);
            }
            if (b.hitFlash > 0) b.hitFlash -= dt;
        }
    }

    function handleCollision() {
        const p = game.player;
        if (!p) return;
        
        for (let i = game.playerArrows.length - 1; i >= 0; i--) {
            const arrow = game.playerArrows[i];
            let arrowHit = false;

            for (let j = game.attackProjectiles.length - 1; j >= 0; j--) {
                const atk = game.attackProjectiles[j];
                const dx = arrow.x - atk.x;
                const dy = arrow.y - atk.y;
                if (Math.sqrt(dx*dx + dy*dy) < atk.r + 10) {
                    game.effects.push(createEffect(atk.x, atk.y, "#fff")); 
                    game.attackProjectiles.splice(j, 1);
                    arrowHit = true;
                    break;
                }
            }
            if (arrowHit) {
                game.playerArrows.splice(i, 1);
                continue;
            }

            for (let j = game.ghosts.length - 1; j >= 0; j--) {
                const g = game.ghosts[j];
                const dx = arrow.x - g.x;
                const dy = arrow.y - g.y;
                if (Math.sqrt(dx*dx + dy*dy) < g.r + 10) {
                    game.effects.push(createEffect(g.x, g.y, "#ff3b30")); 
                    game.ghosts.splice(j, 1);
                    respawnGhost(); 
                    arrowHit = true;
                    break;
                }
            }
            if (arrowHit) {
                game.playerArrows.splice(i, 1);
                continue;
            }

            if (game.boss) {
                const b = game.boss;
                const dx = arrow.x - b.x;
                const dy = arrow.y - b.y;
                if (Math.sqrt(dx*dx + dy*dy) < b.r + 5) {
                     b.hitFlash = 0.1;
                     game.effects.push(createEffect(arrow.x, arrow.y, "#ffff00"));
                     game.playerArrows.splice(i, 1);
                     continue;
                }
            }
        }

        for (const g of game.ghosts) {
            const dx = p.x - g.x;
            const dy = p.y - g.y;
            if(Math.sqrt(dx*dx + dy*dy) < g.r + 15) {
                game.hp -= 1;
                game.hitEffectTime = 0.3;
                g.vx = -g.vx; 
                g.x += 30; 
                if(game.hp <= 0) gameOver();
                return; 
            }
        }

        if (game.boss) {
            const b = game.boss;
            const dx = p.x - b.x;
            const dy = p.y - b.y;
            if(Math.sqrt(dx*dx + dy*dy) < b.r + 15) {
                game.hp -= 2;
                game.hitEffectTime = 0.4;
                p.x -= 60;
                if(game.hp <= 0) gameOver();
                return;
            }
        }

        for (let i = game.wordProjectiles.length - 1; i >= 0; i--) {
            const prj = game.wordProjectiles[i];
            const dx = p.x - prj.x;
            const dy = p.y - prj.y;
            
            if(Math.sqrt(dx*dx + dy*dy) < prj.r + 15) {
                game.wordProjectiles.splice(i, 1);
                if (prj.isCorrect) {
                    game.flashTime = 0.2;
                    game.currentIndex++;
                    game.wordProjectiles = []; 

                    if (game.level === 2 && game.boss) {
                         game.goldenWaves.push(createGoldenWave(p.x, p.y, game.boss.x, game.boss.y));
                    }
                    
                    if (game.currentIndex >= game.currentQuestions.length) {
                        if (game.level === 1) {
                            setTimeout(startLevel2, 500); // ä¿®æ­£ Level 1 å¾ªç’°éŒ¯èª¤ï¼Œç¢ºä¿æ­£ç¢ºé€²å…¥ Level 2
                        } else {
                            // ç¬¬äºŒé—œï¼šç­‰å¾…å…‰æ³¢æ“Šä¸­ Boss è§¸ç™¼å‹åˆ©ï¼Œé€™è£¡åªé¡¯ç¤ºè¨Šæ¯
                            messageEl.textContent = "æœ€å¾Œä¸€æ“Šç™¼å°„ï¼";
                        }
                    } else {
                        updateQuestionDisplay();
                        updateUI("Nice! ä¸‹ä¸€é¡Œï¼", game.level === 1 ? "é—œå¡ 1" : "é—œå¡ 2", `${game.currentIndex} / ${game.currentQuestions.length}`);
                    }
                } else {
                    game.hitEffectTime = 0.3;
                    game.hp--;
                    messageEl.textContent = "é¸éŒ¯å­—äº†ï¼";
                    if(game.hp <= 0) gameOver();
                }
                return;
            }
        }

        for (let i = game.attackProjectiles.length - 1; i >= 0; i--) {
            const atk = game.attackProjectiles[i];
            const dx = p.x - atk.x;
            const dy = p.y - atk.y;
            if(Math.sqrt(dx*dx + dy*dy) < atk.r + 12) {
                game.attackProjectiles.splice(i, 1);
                game.hitEffectTime = 0.3;
                game.hp -= (atk.type === 'beam' ? 2 : 1);
                if(game.hp <= 0) gameOver();
                return;
            }
        }
    }

    function update(dt) {
        if (game.state !== "level1" && game.state !== "level2") return;

        game.wordSpawnTimer -= dt;
        const spawnInterval = game.level === 1 ? 1.4 : 1.2;
        if(game.wordSpawnTimer <= 0) {
            spawnWord();
            game.wordSpawnTimer = spawnInterval;
        }

        updateEnemies(dt);

        const p = game.player;
        if (p.attackCooldown > 0) p.attackCooldown -= dt;
        
        p.vx = 0; p.vy = 0;
        if (keys["ArrowLeft"]) p.vx = -p.speed;
        if (keys["ArrowRight"]) p.vx = p.speed;
        if (keys["ArrowUp"]) p.vy = -p.speed;
        if (keys["ArrowDown"]) p.vy = p.speed;

        if (game.touchTarget) {
            const dx = game.touchTarget.x - p.x;
            const dy = game.touchTarget.y - p.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist > 10) {
                p.vx = (dx / dist) * p.speed;
                p.vy = (dy / dist) * p.speed;
            }
        }
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.x = Math.max(30, Math.min(WIDTH - 30, p.x));
        p.y = Math.max(30, Math.min(HEIGHT - 30, p.y));

        for (let i = game.playerArrows.length - 1; i >= 0; i--) {
            const a = game.playerArrows[i];
            a.x += a.vx * dt;
            a.life -= dt;
            if(a.life <= 0 || a.x > WIDTH) game.playerArrows.splice(i, 1);
        }

        for (let i = game.goldenWaves.length - 1; i >= 0; i--) {
            const wave = game.goldenWaves[i];
            
            if (game.boss && game.boss.hp > 0) {
                const targetX = game.boss.x;
                const targetY = game.boss.y;
                const angleToBoss = Math.atan2(targetY - wave.y, targetX - wave.x);
                wave.vx = Math.cos(angleToBoss) * wave.speed;
                wave.vy = Math.sin(angleToBoss) * wave.speed;
                wave.angle = angleToBoss;
            }

            wave.x += wave.vx * dt;
            wave.y += wave.vy * dt;
            wave.life -= dt;

            if (game.boss && game.boss.hp > 0) {
                const b = game.boss;
                const dx = wave.x - b.x;
                const dy = wave.y - b.y;
                if (Math.sqrt(dx*dx + dy*dy) < b.r + wave.r) {
                    b.hp -= 1;
                    b.hitFlash = 0.2; 
                    game.effects.push(createEffect(b.x, b.y, "#ffd700", 80)); 
                    game.goldenWaves.splice(i, 1);

                    if (b.hp <= 0) {
                        game.boss = null; 
                        game.effects.push(createEffect(b.x, b.y, "#fff", 200)); 
                        setTimeout(victory, 1000);
                    }
                    continue;
                }
            }

            if(wave.life <= 0 || wave.x > WIDTH + 100) game.goldenWaves.splice(i, 1);
        }

        for (let i = game.effects.length - 1; i >= 0; i--) {
            const e = game.effects[i];
            e.r += 60 * dt; 
            e.alpha -= 2.0 * dt; 
            e.life -= dt;
            if(e.life <= 0) game.effects.splice(i, 1);
        }

        [game.wordProjectiles, game.attackProjectiles].forEach(arr => {
            for (let i = arr.length - 1; i >= 0; i--) {
                const prj = arr[i];
                prj.x += prj.vx * dt;
                prj.y += prj.vy * dt;
                prj.life -= dt;
                if(prj.life <= 0 || prj.x < -50 || prj.x > WIDTH + 50 || prj.y < -50 || prj.y > HEIGHT + 50) {
                    arr.splice(i, 1);
                }
            }
        });

        handleCollision();

        if (game.flashTime > 0) game.flashTime -= dt;
        if (game.hitEffectTime > 0) game.hitEffectTime -= dt;
    }

    // ====== ç¹ªåœ– ======
    function draw() {
        const grad = ctx.createLinearGradient(0, 0, 0, HEIGHT);
        grad.addColorStop(0, "#141826");
        grad.addColorStop(1, "#05060b");
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, WIDTH, HEIGHT);

        // è£é£¾
        ctx.fillStyle = "#1e2230";
        ctx.fillRect(WIDTH * 0.85, 80, 80, HEIGHT - 160);

        ctx.fillStyle = "#ffe066";
        for (const a of game.playerArrows) {
             ctx.fillRect(a.x, a.y - 3, 20, 6);
             ctx.shadowBlur = 10;
             ctx.shadowColor = "#ffcc00";
             ctx.fillRect(a.x, a.y - 3, 20, 6);
             ctx.shadowBlur = 0;
        }

        for (const w of game.goldenWaves) {
             ctx.save();
             ctx.translate(w.x, w.y);
             ctx.rotate(w.angle);
             ctx.fillStyle = "#ffd700";
             ctx.beginPath();
             ctx.arc(0, 0, w.r, 0, Math.PI * 2);
             ctx.fill();
             // æ‹–å°¾æ•ˆæœ
             ctx.fillStyle = "rgba(255, 215, 0, 0.5)";
             ctx.beginPath();
             ctx.moveTo(0, -w.r);
             ctx.lineTo(-60, 0);
             ctx.lineTo(0, w.r);
             ctx.fill();
             ctx.restore();
        }

        for(const atk of game.attackProjectiles) {
            ctx.save();
            ctx.translate(atk.x, atk.y);
            ctx.rotate(atk.rotation);
            ctx.fillStyle = atk.color;
            ctx.beginPath();
            if (atk.type === 'fire') {
                ctx.arc(0, 0, atk.r, 0, Math.PI*2);
                ctx.fill();
                ctx.fillStyle = "#ffff00"; 
                ctx.beginPath(); ctx.arc(-2, -2, atk.r*0.5, 0, Math.PI*2); ctx.fill();
            } else {
                ctx.scale(1.5, 1);
                ctx.arc(0, 0, atk.r, 0, Math.PI*2);
                ctx.fillStyle = "#00ccff";
                ctx.shadowBlur = 15;
                ctx.shadowColor = "#00ccff";
                ctx.fill();
                ctx.fillStyle = "#ffffff";
                ctx.beginPath(); ctx.arc(0, 0, atk.r*0.6, 0, Math.PI*2); ctx.fill();
            }
            ctx.restore();
        }

        // [ä¿®æ”¹] æ³¡æ³¡æ–‡å­—å°ºå¯¸æ”¾å¤§
        ctx.font = "bold 26px sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        for(const prj of game.wordProjectiles) {
            ctx.beginPath();
            ctx.ellipse(prj.x, prj.y, prj.r, Math.min(prj.r, 28), 0, 0, Math.PI*2);
            ctx.fillStyle = "rgba(255, 255, 255, 0.95)";
            ctx.shadowBlur = 8;
            ctx.shadowColor = "rgba(255,255,255,0.4)";
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.fillStyle = "#000";
            ctx.fillText(prj.text, prj.x, prj.y);
        }

        for(const g of game.ghosts) {
            ctx.globalAlpha = g.alpha;
            // [ä¿®æ”¹] ç¹ªè£½å°ºå¯¸æ”¾å¤§
            const size = g.r * 2.2; 
            ctx.drawImage(assets.ghost, g.x - size/2, g.y - size/2, size, size);
            
            if (g.attackCooldown < 0.5) {
               ctx.fillStyle = "rgba(255,0,0,0.5)";
               ctx.beginPath();
               ctx.arc(g.x, g.y - 5, 4, 0, Math.PI*2);
               ctx.fill();
            }
            ctx.globalAlpha = 1;
        }

        if(game.boss && game.boss.hp > 0) {
            const b = game.boss;
            const size = b.r * 2.2;
            
            ctx.save();
            if (b.hitFlash > 0) {
                ctx.globalAlpha = 0.6; 
                ctx.filter = "brightness(200%)";
            }
            
            ctx.drawImage(assets.boss, b.x - size/2, b.y - size/2, size, size);
            ctx.restore();

            if (b.hitFlash > 0) {
                 ctx.strokeStyle = "rgba(255,255,255,0.8)";
                 ctx.lineWidth = 4;
                 ctx.beginPath();
                 ctx.arc(b.x, b.y, b.r + 5, 0, Math.PI*2);
                 ctx.stroke();
            }
        }

        const p = game.player;
        if(p) {
            ctx.save();
            // [ä¿®æ”¹] ç¹ªè£½å°ºå¯¸æ”¾å¤§
            const size = p.w * 1.2;
            ctx.drawImage(assets.player, p.x - size/2, p.y - size/2, size, size);
            ctx.restore();

            if (game.touchTarget) {
               ctx.strokeStyle = "rgba(255,255,255,0.3)";
               ctx.beginPath(); ctx.moveTo(p.x, p.y);
               ctx.lineTo(game.touchTarget.x, game.touchTarget.y); ctx.stroke();
            }
        }

        for(const e of game.effects) {
            ctx.globalAlpha = e.alpha;
            ctx.fillStyle = e.color;
            ctx.beginPath();
            ctx.arc(e.x, e.y, e.r, 0, Math.PI*2);
            ctx.fill();
            ctx.globalAlpha = 1;
        }

        // ç¹ªè£½ HP & Boss è¡€æ¢ (ç›´æ¥ç•«åœ¨ Canvas ä¸Šæ¯” HTML DOM é †æš¢)
        ctx.fillStyle = "#fff";
        ctx.font = "14px sans-serif";
        ctx.textAlign = "left";
        ctx.fillText(`HP: ${game.hp} / ${game.maxHp}`, 20, 30);
        ctx.fillStyle = "#444";
        ctx.fillRect(80, 18, 100, 12);
        ctx.fillStyle = game.hp > 2 ? "#4cd964" : "#ff3b30";
        ctx.fillRect(80, 18, 100 * (game.hp / game.maxHp), 12);

        if (game.level === 2 && game.boss) {
            const b = game.boss;
            const barW = 200;
            const barX = WIDTH/2 - barW/2;
            const barY = 50;
            ctx.fillStyle = "rgba(0,0,0,0.6)";
            ctx.fillRect(barX, barY, barW, 10);
            ctx.fillStyle = "#ff3333";
            ctx.fillRect(barX, barY, barW * (Math.max(0,b.hp) / b.maxHp), 10);
            ctx.strokeStyle = "#fff";
            ctx.lineWidth = 1;
            ctx.strokeRect(barX, barY, barW, 10);
            ctx.textAlign = "center";
            ctx.fillStyle = "#fff";
            ctx.fillText("é­”ç‹ HP", WIDTH/2, barY - 5);
        }

        if (game.hitEffectTime > 0) {
            ctx.fillStyle = `rgba(255, 0, 0, ${game.hitEffectTime})`;
            ctx.fillRect(0,0,WIDTH,HEIGHT);
        }
        if (game.flashTime > 0) {
            ctx.fillStyle = `rgba(255, 255, 200, ${game.flashTime})`;
            ctx.fillRect(0,0,WIDTH,HEIGHT);
        }

        if (game.state === "menu") {
            ctx.fillStyle = "rgba(0,0,0,0.7)";
            ctx.fillRect(0,0,WIDTH,HEIGHT);
            ctx.fillStyle = "#fff";
            ctx.font = "30px sans-serif";
            ctx.textAlign = "center";
            ctx.fillText("è³¢è€…é—–é¬¼å±‹", WIDTH/2, HEIGHT/2);
            ctx.font = "16px sans-serif";
            ctx.fillText("è«‹æŒ‰å·¦æ–¹/ä¸Šæ–¹æŒ‰éˆ•é–‹å§‹", WIDTH/2, HEIGHT/2 + 40);
        }
    }

    function loop(time) {
        const dt = (time - game.lastTime) / 1000;
        game.lastTime = time;
        update(Math.min(dt, 0.1));
        draw();
        requestAnimationFrame(loop);
    }
    game.lastTime = performance.now();
    requestAnimationFrame(loop);
  </script>
</body>
</html>